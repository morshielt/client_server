SERWER:
[] MEM_SIZE ~ udostępnia pewną zadaną przestrzeń pamięci nieulotnej

[] MCAST_ADDR ~ węzły tworzą grupę dzięki wykorzystaniu tego samego adresu IP Multicast
// + CMD_PORT – numer portu UDP, na którym węzły serwerowe danej grupy nasłuchują pakietów
// ++ serwer powinien nasłuchiwać pakietów UDP na porcie CMD_PORT pod adresem rozgłoszeniowym MCAST_ADDR oraz swoim adresem jednostkowym (ang. unicast)

[] serwer poznaje adres jednostkowy klienta na podstawie otrzymanego datagramu protokołu UDP

[] dowolna #plików o łącznym rozmiarze nieprzekraczającym łącznej przestrzeni dyskowej udostępnianej przez wszystkie węzły serwerowe w danej grupie.

[] Łączna przestrzeń do przechowywania plików zmienia się dynamicznie wraz z dołączaniem i odłączaniem się węzłów serwerowych w grupie.

[] Pliki przechowywane przez dowolny węzeł serwerowy widoczne są przez wszystkie węzły klienckie w danej grupie.

[] Pliki przechowywane są niepodzielnie: jeden plik w całości przechowywany jest w pamięci nieulotnej węzła serwerowego.

[] Pliki identyfikowane są po nazwie, a wielkość liter ma znaczenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Parowanie odpowiedzi serwera z zapytaniami klienta:
[] Klient przy [wysyłaniu każdego zapytania] do serwera powinien wypełnić zawartość pola
[cmd_seq unikalną wartością numeryczną] umożliwiającą klientowi [rozpoznawanie odpowiedzi serwera lub serwerów].

[] Jeśli klient w trakcie swojego działania [otrzyma pakiet danych], w którym wartość pola [cmd_seq nie pokrywa się z wartością wysłaną i oczekiwaną w odpowiedzi],
to klient powinien wypisać na [standardowy strumień błędów] [jednoliniowy komunikat błędu] o formacie określonym dalej w treści zadania.

[] Serwer w odpowiedzi powinien [zawsze przepisać wartość pola cmd_seq] z otrzymanego pakietu do pola o takiej
    samej nazwie w pakiecie z odpowiedzią.

(!) Dalej w treści zadania pole cmd_seq nie będzie wspominane dla lepszej czytelności i przejrzystości, ale jest
    ono obligatoryjne we wszystkich wysyłanych pakietach.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Rozpoznawanie listy serwerów w grupie:
[] >HELLO< ~ W celu poznania listy aktywnych węzłów serwerowych w grupie klient
wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
pakiet SIMPL_CMD z poleceniem cmd = “HELLO” oraz pustą zawartością pola data.

[] <GOOD_DAY> ~ Każdy z węzłów serwerowych po otrzymaniu powyższego pakietu powinien // ale to (a) jeden z każdej grupy ma odpowiedzieć czy (b) zupełnie wszyscy?
> odpowiedzieć do nadawcy bezpośrednio na jego [adres jednostkowy i port nadawcy] pakietem CMPLX_CMD zawierającym:
· pole cmd z wartością “GOOD_DAY”;
· pole param z wartością wolnej przestrzeni dyskowej na przechowywanie plików;
· pole data z wartością tekstową zawierającą adres MCAST_ADDR, na jakim serwer nasłuchuje, w notacji kropkowej.

>>> Przeglądanie listy plików i wyszukiwanie na serwerach w grupie:
[] >LIST< ~ W celu poznania listy wszystkich plików aktualnie przechowywanych w węzłach [danej grupy] klient
    wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “LIST” i pustą wartością pola data.

[] >LIST< [z ciągiem znaków] ~ W celu odnalezienia w grupie plików [zawierających w nazwie zadany ciąg znaków] klient
    wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “LIST” oraz szukanym ciągiem znaków w polu data.

[] <MY_LIST> ~ Każdy węzeł serwerowy po otrzymaniu jednego z powyższych pakietów powinien
> odpowiedzieć nadawcy bezpośrednio na jego adres jednostkowy i port nadawcy pakietem SIMPL_CMD:
· pole cmd z wartością “MY_LIST”.
· pole data powinno zawierać listę nazw plików przechowywanych przez dany węzeł: [SPECYFIKACJA][LISTA PLIKÓW]
·· nazwy plików powinien rozdzielać znak nowego wiersza (znakiem nowego wiersza jest ‘\n’)
·· jeśli lista wszystkich nazw plików danego serwera spowodowałaby przekroczenie dopuszczalnego rozmiaru jednego pakietu danych UDP,
to serwer powinien podzielić listę nazw swoich plików na odpowiednią liczbę pakietów,
    wysyłając wielokrotnie odpowiedź “MY_LIST” z kolejnymi nazwami plików, aż do wysłania całej listy.
·· zakładamy, że nie obsługujemy plików o nazwach przekraczających dopuszczalny rozmiar danych jednego pakietu UDP.

Jeśli otrzymany przez serwer pakiet z cmd = “LIST” zawiera niepusty ciąg znaków w polu data,
to serwer powinien w odpowiedzi przesłać tylko te nazwy plików, które zawierają ów niepusty ciąg znaków
(wielkość liter ma znaczenia przy porównywaniu nazw plików).
(!) [CORNER_CASE] Jeśli żadna nazwa pliku nie zawiera poszukiwanego ciągu znaków,
to serwer nie odpowiada żadnym pakietem do nadawcy na otrzymane zapytanie.
(!) [CORNER_CASE] Reakcja serwera będzie taka sama, jeśli nie przechowuje obecnie żadnego pliku.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Pobieranie pliku z serwera:
Dowolny węzeł kliencki ma prawo pobrać dowolny plik z dowolnego węzła serwerowego w danej grupie.
[] >GET< ~ W celu rozpoczęcia pobierania konkretnego pliku klient wysyła
do wybranego węzła serwerowego na jego adres jednostkowy i port CMD_PORT
pakiet SIMPL_CMD z poleceniem cmd = “GET” oraz nazwą pliku w polu data.

[] <CONNECT_ME> ~ Serwer po otrzymaniu powyższego komunikatu
> odpowiada nadawcy na jego adres jednostkowy i port nadawczy pakietem CMPLX_CMD zawierającymi:
· pole cmd = “CONNECT_ME”;
· pole param z numerem portu TCP, na którym oczekuje połączenia od klienta;
· pole data z nazwą pliku, który zostanie wysłany.
//XXX
(!) [CORNER_CASE] Jeśli serwer otrzyma pakiet z żądaniem pobrania pliku, którego serwer nie ma,
to serwer nie odpowiada na taki pakiet, ale powinien odnotować otrzymanie
niewłaściwego pakietu zgodnie ze specyfikacją opisaną w dalszej treści.

[] >GET< [wymianka] ~ Klient po otrzymaniu powyższego komunikatu od serwera powinien nawiązać połączenie TCP z węzłem serwerowym,
    używając jego adresu jednostkowego oraz otrzymanego portu TCP.
Serwer po nawiązaniu połączenia z klientem wysyła zawartość pliku i kończy połączenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Usuwanie pliku z serwera:
Dowolny węzeł kliencki ma prawo skasować dowolny plik z dowolnego węzła serwerowego w danej grupie.
[] >DEL< ~ Klient w celu skasowania danego pliku z grupy wysyła
    na adres rozgłoszeniowy MCAST_ADDR ((!) [CORNER_CASE] dozwolone jest wysłanie także na adres unicast wybranego serwera) i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “DEL” oraz z nazwą pliku do skasowania w polu data.

[] Każdy węzeł serwerowy po otrzymaniu powyższego komunikatu usuwa trwale plik wskazany nazwą, jeśli taki przechowuje.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Dodawanie pliku do grupy:
Klient w celu wysłania pliku do przechowywania go w grupie musi najpierw
> wyznaczyć węzeł, który będzie przechowywał ten plik.
W tym celu może wykorzystać polecenie służące rozpoznawaniu serwerów w grupie opisane wcześniej (patrz opis dla cmd = “HELLO”).

[] >ADD< ~ Po wybraniu serwera klient komunikuje się z nim,
    wysyłając na jego adres jednostkowy oraz port CMD_PORT pakiet CMPLX_CMD zawierający:
· pole cmd = “ADD”;
· pole param z rozmiarem pliku;
· pole data z nazwą pliku, który zostanie wysłany.

[] Węzeł serwerowy po otrzymaniu powyższego komunikatu musi odpowiedzieć klientowi
> w zależności od aktualnej możliwości przyjęcia pliku:
<NO_WAY> ::
>> jeśli serwer nie ma już miejsca na przechowanie pliku o rozmiarze wskazanym przez klienta,
    to odpowiada klientowi, wysyłając na jego adres jednostkowy i port nadawcy
    pakiet SIMPL_CMD:
· cmd = “NO_WAY”
· nazwą pliku, jaki klient chciał dodać, w polu data.
>> jeśli serwer przechowuje już obecnie plik o wskazanej przez węzeł kliencki nazwie,
    to serwer także powinien odpowiedzieć klientowi, wysyłając na jego adres
jednostkowy i port nadawcy pakiet SIMPL_CMD z cmd = “NO_WAY” oraz nazwą pliku,
jaki klient chciał dodać w polu data.
>> serwer powinien odmówić przyjęcia pliku także w przypadku gdy
– otrzymana nazwa pliku jest pusta
– lub zawiera znak '/’,
wysyłając na adres jednostkowy i port nadawcy pakiet SIMPL_CMD
· cmd = “NO_WAY”
· nazwą pliku, jaki klient chciał dodać, w polu data.
<CAN_ADD> ::
>> jeśli natomiast serwer dysponuje obecnie wolnym miejscem pozwalającym przechować
    plik o rozmiarze wskazanym przez nadawcę, to odpowiada klientowi na
jego adres jednostkowy i port nadawcy pakietem CMPLX_CMD zawierającym:
· pole cmd z wartością “CAN_ADD”;
· pole param z numerem portu TCP, na którym serwer oczekuje połączenia od klienta;
· pole data pozostaje puste.

[] >ADD< [wymianka] ~ Klient po otrzymaniu powyższego komunikatu powinien nawiązać połączenie TCP z węzłem serwerowym,
    używając jego adresu jednostkowego oraz otrzymanego portu TCP.
> Klient wysyła zawartość pliku, po czym powinien zakończyć połączenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KLIENT:
[] umożliwia dodanie nowego pliku do plików przechowywanych przez grupę lub usunięcie dowolnego istniejącego pliku.

[] umożliwia pobranie zawartości dowolnego pliku z obecnie przechowywanych plików w grupie węzłów serwerowych

[] umożliwia pobranie listy plików obecnie przechowywanych w grupie węzłów serwerowych.


[] KOMUNIKATY:

[X] SIMPL_CMD {
char[10] cmd    (2)
uint64 cmd_seq  (1)
char[] data
}

[X] CMPLX_CMD {
char[10] cmd    (2)
uint64 cmd_seq  (1)
uint64 param    (1)
char[] data
}

[?][muszę rzutawać czy przy przekazaniu się zrzutuje? D:]
(1) w BE(sieciowa kolejność); dla zmiennej o < 64 bity zrzutować (uint64) i użyć htobe64();

(2) krótsza wartość niż 10 znaków => uzupełnić zerami~ (zrobić wcześniej memset? przechowywać uzupełnione z zerami?)
// uh oh, memset to chyba nie, bo utnie, chcemy prawdziwe zera?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MISC_INFO:
> Wszystkie rozmiary plików i przestrzeni dyskowej wyrażane są w liczbie bajtów.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Część A - Węzeł serwerowy:
[] Program powinien przyjmować następujące parametry linii poleceń:
> [-g] ~ MCAST_ADDR – adres rozgłaszania ukierunkowanego, ustawiany obowiązkowym parametrem -g węzła serwerowego;

> [-p] ~ CMD_PORT – port UDP używany do przesyłania i odbierania poleceń, ustawiany obowiązkowym parametrem -p węzła serwerowego;

> [-b] ~ MAX_SPACE – maksymalna liczba bajtów udostępnianej przestrzeni dyskowej na pliki grupy
    przez ten węzeł serwerowy, ustawiana opcjonalnym parametrem -b węzła serwerowego, wartość domyślna 52428800;

> [-f] ~ SHRD_FLDR – ścieżka do dedykowanego folderu dyskowego, gdzie mają być przechowywane pliki,
ustawiany parametrem obowiązkowym -f węzła serwerowego;

> [-t] ~ TIMEOUT – liczba sekund, jakie serwer może maksymalnie oczekiwać na połączenia od klientów,
    ustawiane opcjonalnym parametrem -t węzła serwerowego, wartość domyślna 5, wartość maksymalna 300.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] Serwer podczas uruchomienia powinien zindeksować wszystkie pliki znajdujące się bezpośrednio w folderze SHRD_FLDR,
a ich łączny rozmiar liczony w bajtach odjąć od parametru MAX_SPACE.
Serwer nie indeksuje plików w podkatalogach folderu SHRD_FLDR.

[] Serwer powinien podłączyć się do grupy rozgłaszania ukierunkowanego pod wskazanym adresem MCAST_ADDR.
Serwer powinien nasłuchiwać na porcie CMD_PORT poleceń otrzymanych z sieci protokołem UDP
także na swoim adresie unicast. Serwer powinien reagować na pakiety UDP zgodnie z protokołem opisanym wcześniej.

[] Jeśli serwer otrzyma polecenie dodania pliku lub pobrania pliku, to powinien otworzyć nowe gniazdo TCP
na losowym wolnym porcie przydzielonym przez system operacyjny i port ten przekazać w odpowiedzi
węzłowi klienckiemu. Serwer oczekuje maksymalnie TIMEOUT sekund na nawiązanie połączenia przez klienta
i jeśli takie nie nastąpi, to port TCP powinien zostać niezwłocznie zamknięty. (!) Serwer w czasie oczekiwania
na podłączenie się klienta i podczas przesyłania pliku powinien obsługiwać także inne zapytania od klientów.

[] Jeśli serwer otrzyma polecenia dodania pliku, to odpowiedź klientowi pakietem “CAN_ADD”
oznacza jednocześnie zarezerwowanie miejsca na serwerze niezbędnego do przyjęcia pliku od klienta.

[] Jakiekolwiek pakiety otrzymane przez program niezgodne ze specyfikacją protokołu powinny być pomijane przez serwer.
Informacja o niewłaściwym pakiecie powinna zostać wypisana na standardowe wyjście błędów,
jednolinijkowy komunikat o błędzie dla każdego niepoprawnego pakietu.
Informacja o błędzie powinna zawierać informację w formacie: [SPECYFIKACJA]

[PCKG ERROR] Skipping invalid package from {IP_NADAWCY}:{PORT_NADAWCY}.

gdzie {IP_NADAWCY} jest adresem IP nadawcy otrzymanego datagramu UDP
    a {PORT_NADAWCY} jest numerem portu nadawcy datagramu UDP

Autor programu powinien uzupełnić wiadomość po kropce o dodatkowe informacje opisujące błąd, ale bez użycia znaku nowej linii.

[] Serwer powinien zakończyć swoje działanie łagodnie, to znaczy kończąc otwarte połączenia oraz zwalniając pobrane zasoby systemowe, po otrzymaniu sygnału CTRL+C.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Część B - Węzeł kliencki:
[] Program powinien przyjmować następujące parametry linii poleceń:

[]  > [-g] ~ MCAST_ADDR – adres rozgłaszania ukierunkowanego (może być także adresem broadcast),
ustawiany {{obowiązkowym}} parametrem -g;
klient powinien używać tego adresu do wysyłania komunikatów do grupy węzłów serwerowych;

[]  > [-p] ~ CMD_PORT – port UDP, na którym nasłuchują węzły serwerowe, ustawiany {{obowiązkowym}} parametrem -p;
klient powinien używać tego numeru portu, aby wysyłać komunikaty do węzłów serwerowych;
// [0 - 65XXX]

> [-o] ~ OUT_FLDR – ścieżka do folderu dyskowego, gdzie klient będzie zapisywał pobrane pliki,
ustawiany parametrem {{obowiązkowym}} -o;
// walidacja

> [-t] ~ TIMEOUT – czas oczekiwania na zbieranie informacji od węzłów wyrażony w sekundach;
akceptowana wartość powinna być dodatnia i większa od zera; {{wartość domyślna 5}}; wartość maksymalna 300;
może zostać zmieniona przez opcjonalny parametr -t.
// [0 - 300]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] Klient po rozpoczęciu swojej pracy powinien oczekiwać na polecenia użytkownika na standardowym wejściu.
Każde polecenie kończy się znakiem nowej linii '\n'.
[]    Rozpoznawane przez program kliencki polecenia użytkownika (wielkość liter nie ma znaczenia):

[]  · discover – po otrzymaniu tego polecenia klient powinien wypisać na standardowe wyjście listę wszystkich węzłów serwerowych dostępnych aktualnie w grupie.
Klient oczekuje na zgłoszenia serwerów przez TIMEOUT sekund, w trakcie oczekiwania interfejs użytkownika zostaje wstrzymany.
Dla każdego odnalezionego serwera klient powinien wypisać na standardowe wyjście w jednej linii adres jednostkowy IP tego serwera,
    następnie w nawiasie adres MCAST_ADDR otrzymany od danego serwera, a na końcu rozmiar dostępnej przestrzeni dyskowej na tym serwerze.
Oczekiwany format takiej linii:

Found 10.1.1.28 (239.10.11.12) with free space 23456

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · search %s – klient powinien uznać polecenie za prawidłowe, także jeśli podany ciąg znaków %s jest pusty.
Po otrzymaniu tego polecenia klient wysyła po sieci do węzłów serwerowych zapytanie w celu wyszukania plików
    zawierających ciąg znaków podany przez użytkownika (lub wszystkich plików jeśli ciąg znaków %s jest pusty),
a następnie przez TIMEOUT sekund nasłuchuje odpowiedzi od węzłów serwerowych. Otrzymane listy plików powinny
zostać wypisane na standardowe wyjście po jednej linii na  jeden plik. Każda linia powinna zawierać informację:

{nazwa_pliku} ({ip_serwera})

gdzie:
– {nazwa_pliku} to nazwa pliku otrzymana z serwera;
– {ip_serwera} to adres jednostkowy IP serwera, z którego dana nazwa pliku została przesłana.

[]  Pakiety z odpowiedziami od serwerów z listą plików otrzymane po upływie TIMEOUT powinny zostać zignorowane przez klienta.
[]  Interfejs użytkownika zostaje wstrzymany na czas oczekiwania odpowiedzi z serwerów.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] · fetch %s – użytkownik może wskazać nazwę pliku %s, tylko jeśli nazwa pliku występowała na liście otrzymanej
w wyniku ostatniego wykonania polecenia search. (!) W przeciwnym przypadku klient nie podejmuje akcji pobierania pliku,
jednocześnie informując użytkownika o błędzie jednoliniowym komunikatem na standardowe wyjście.

[] Jeśli wskazany plik istnieje w [ostatnio wyszukiwanych (???)], to klient powinien wybrać dowolny węzeł serwerowy,
który przechowuje plik dokładnie wskazany przez podaną nazwę pliku %s i rozpocząć pobieranie pliku, zapisując plik do folderu OUT_FLDR.
[] W trakcie pobierania pliku użytkownik powinien móc kontynuować korzystanie z programu. Po zakończeniu pobierania pliku klient powinien
wypisać na standardowe wyjście komunikat o zakończeniu pobierania pliku w formacie:

File {%s} downloaded ({ip_serwera}:{port_serwera})

gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres IP unicast serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku.

Jeśli pobieranie pliku nie powiedzie się, to klient powinien wypisać na standardowe wyjście komunikat o błędzie w formacie:
File {%s} downloading failed ({ip_serwera}:{port_serwera}) {opis_błędu}

gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy IP serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku;
– {opis_błędu} to komunikat słowny opisujący przyczynę błędu.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] · upload %s – użytkownik powinien wskazać ścieżkę do pliku, który chce wysłać do przechowania w grupie.
Użytkownik [[może]] podać pełną ścieżkę bezwzględną do pliku bądź ścieżkę względną.
Jeśli użytkownik wskaże nazwę pliku poprzez ścieżkę względną, to należy rozpocząć szukanie pliku do wysłania w katalogu bieżącym.
Jeśli wskazany plik nie istnieje, to klient powinien poinformować o tym fakcie użytkownika jednoliniową
    informacją o błędzie na standardowe wyjście w formacie

    File {%s} does not exist
    gdzie:
– {%s} to nazwa pliku.

[] Klient powinien podjąć próbę wysłania pliku [w pierwszej kolejności do węzła serwerowego o największej dostępnej wolnej przestrzeni].
Jeśli żaden węzeł nie dysponuje wystarczającym wolnym miejscem, to klient powinien poinformować użytkownika o braku możliwości załadowania pliku,
wypisując jednoliniową informację o błędzie na standardowe wyjście w formacie:

File {%s} too big
gdzie:
– {%s} to nazwa pliku.

[] W trakcie wysyłania pliku użytkownik powinien móc w dalszym ciągu korzystać z aplikacji.
Po zakończeniu wysyłania pliku klient powinien wypisać na standardowe wyjście komunikat o zakończeniu wysyłania pliku w formacie:

File {%s} uploaded ({ip_serwera}:{port_serwera})
gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku.

[] Jeśli wysyłanie pliku nie powiedzie się, to klient powinien wypisać na standardowe wyjście komunikat o błędzie w fomacie:

File {%s} uploading failed ({ip_serwera}:{port_serwera}) {opis_błędu}
gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy serwera
– {port_serwera} to port TCP serwera użyty do pobrania pliku;
– {opis_błędu} to komunikat słowny opisujący przyczynę błędu.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · remove %s – klient po otrzymaniu tego polecenia powinien wysłać do grupy serwerów
zlecenie usunięcia wskazanego przez użytkownika pliku. Polecenie jest prawidłowe,
tylko jeśli podana nazwa pliku %s jest niepusta.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · exit – klient po otrzymaniu tego polecenia powinien zakończyć wszystkie otwarte połączenia
i [zwolnić pobrane zasoby z systemu(???)] oraz zakończyć pracę aplikacji.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MISC KLIENT:

[] Jakiekolwiek inne polecenia wpisane przez użytkownika powinny zostać uznane jako nieprawidłowe i zignorowane.
vSERWER:
[] MEM_SIZE ~ udostępnia pewną zadaną przestrzeń pamięci nieulotnej

[] MCAST_ADDR ~ węzły tworzą grupę dzięki wykorzystaniu tego samego adresu IP Multicast
// + CMD_PORT – numer portu UDP, na którym węzły serwerowe danej grupy nasłuchują pakietów
// ++ serwer powinien nasłuchiwać pakietów UDP na porcie CMD_PORT pod adresem rozgłoszeniowym MCAST_ADDR oraz swoim adresem jednostkowym (ang. unicast)

[] serwer poznaje adres jednostkowy klienta na podstawie otrzymanego datagramu protokołu UDP

[] dowolna #plików o łącznym rozmiarze nieprzekraczającym łącznej przestrzeni dyskowej udostępnianej przez wszystkie węzły serwerowe w danej grupie.

[] Łączna przestrzeń do przechowywania plików zmienia się dynamicznie wraz z dołączaniem i odłączaniem się węzłów serwerowych w grupie.

[] Pliki przechowywane przez dowolny węzeł serwerowy widoczne są przez wszystkie węzły klienckie w danej grupie.

[] Pliki przechowywane są niepodzielnie: jeden plik w całości przechowywany jest w pamięci nieulotnej węzła serwerowego.

[] Pliki identyfikowane są po nazwie, a wielkość liter ma znaczenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Parowanie odpowiedzi serwera z zapytaniami klienta:
[] Klient przy [wysyłaniu każdego zapytania] do serwera powinien wypełnić zawartość pola
[cmd_seq unikalną wartością numeryczną] umożliwiającą klientowi [rozpoznawanie odpowiedzi serwera lub serwerów].

[] Jeśli klient w trakcie swojego działania [otrzyma pakiet danych], w którym wartość pola [cmd_seq nie pokrywa się z wartością wysłaną i oczekiwaną w odpowiedzi],
to klient powinien wypisać na [standardowy strumień błędów] [jednoliniowy komunikat błędu] o formacie określonym dalej w treści zadania.

[] Serwer w odpowiedzi powinien [zawsze przepisać wartość pola cmd_seq] z otrzymanego pakietu do pola o takiej
    samej nazwie w pakiecie z odpowiedzią.

(!) Dalej w treści zadania pole cmd_seq nie będzie wspominane dla lepszej czytelności i przejrzystości, ale jest
    ono obligatoryjne we wszystkich wysyłanych pakietach.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Rozpoznawanie listy serwerów w grupie:
[] >HELLO< ~ W celu poznania listy aktywnych węzłów serwerowych w grupie klient
wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
pakiet SIMPL_CMD z poleceniem cmd = “HELLO” oraz pustą zawartością pola data.

[] <GOOD_DAY> ~ Każdy z węzłów serwerowych po otrzymaniu powyższego pakietu powinien // ale to (a) jeden z każdej grupy ma odpowiedzieć czy (b) zupełnie wszyscy?
> odpowiedzieć do nadawcy bezpośrednio na jego [adres jednostkowy i port nadawcy] pakietem CMPLX_CMD zawierającym:
· pole cmd z wartością “GOOD_DAY”;
· pole param z wartością wolnej przestrzeni dyskowej na przechowywanie plików;
· pole data z wartością tekstową zawierającą adres MCAST_ADDR, na jakim serwer nasłuchuje, w notacji kropkowej.

>>> Przeglądanie listy plików i wyszukiwanie na serwerach w grupie:
[] >LIST< ~ W celu poznania listy wszystkich plików aktualnie przechowywanych w węzłach [danej grupy] klient
    wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “LIST” i pustą wartością pola data.

[] >LIST< [z ciągiem znaków] ~ W celu odnalezienia w grupie plików [zawierających w nazwie zadany ciąg znaków] klient
    wysyła na adres rozgłoszeniowy MCAST_ADDR i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “LIST” oraz szukanym ciągiem znaków w polu data.

[] <MY_LIST> ~ Każdy węzeł serwerowy po otrzymaniu jednego z powyższych pakietów powinien
> odpowiedzieć nadawcy bezpośrednio na jego adres jednostkowy i port nadawcy pakietem SIMPL_CMD:
· pole cmd z wartością “MY_LIST”.
· pole data powinno zawierać listę nazw plików przechowywanych przez dany węzeł: [SPECYFIKACJA][LISTA PLIKÓW]
·· nazwy plików powinien rozdzielać znak nowego wiersza (znakiem nowego wiersza jest ‘\n’)
·· jeśli lista wszystkich nazw plików danego serwera spowodowałaby przekroczenie dopuszczalnego rozmiaru jednego pakietu danych UDP,
to serwer powinien podzielić listę nazw swoich plików na odpowiednią liczbę pakietów,
    wysyłając wielokrotnie odpowiedź “MY_LIST” z kolejnymi nazwami plików, aż do wysłania całej listy.
·· zakładamy, że nie obsługujemy plików o nazwach przekraczających dopuszczalny rozmiar danych jednego pakietu UDP.

Jeśli otrzymany przez serwer pakiet z cmd = “LIST” zawiera niepusty ciąg znaków w polu data,
to serwer powinien w odpowiedzi przesłać tylko te nazwy plików, które zawierają ów niepusty ciąg znaków
(wielkość liter ma znaczenia przy porównywaniu nazw plików).
(!) [CORNER_CASE] Jeśli żadna nazwa pliku nie zawiera poszukiwanego ciągu znaków,
to serwer nie odpowiada żadnym pakietem do nadawcy na otrzymane zapytanie.
(!) [CORNER_CASE] Reakcja serwera będzie taka sama, jeśli nie przechowuje obecnie żadnego pliku.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Pobieranie pliku z serwera:
Dowolny węzeł kliencki ma prawo pobrać dowolny plik z dowolnego węzła serwerowego w danej grupie.
[] >GET< ~ W celu rozpoczęcia pobierania konkretnego pliku klient wysyła
do wybranego węzła serwerowego na jego adres jednostkowy i port CMD_PORT
pakiet SIMPL_CMD z poleceniem cmd = “GET” oraz nazwą pliku w polu data.

[] <CONNECT_ME> ~ Serwer po otrzymaniu powyższego komunikatu
> odpowiada nadawcy na jego adres jednostkowy i port nadawczy pakietem CMPLX_CMD zawierającymi:
· pole cmd = “CONNECT_ME”;
· pole param z numerem portu TCP, na którym oczekuje połączenia od klienta;
· pole data z nazwą pliku, który zostanie wysłany.
//XXX
(!) [CORNER_CASE] Jeśli serwer otrzyma pakiet z żądaniem pobrania pliku, którego serwer nie ma,
to serwer nie odpowiada na taki pakiet, ale powinien odnotować otrzymanie
niewłaściwego pakietu zgodnie ze specyfikacją opisaną w dalszej treści.

[] >GET< [wymianka] ~ Klient po otrzymaniu powyższego komunikatu od serwera powinien nawiązać połączenie TCP z węzłem serwerowym,
    używając jego adresu jednostkowego oraz otrzymanego portu TCP.
Serwer po nawiązaniu połączenia z klientem wysyła zawartość pliku i kończy połączenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Usuwanie pliku z serwera:
Dowolny węzeł kliencki ma prawo skasować dowolny plik z dowolnego węzła serwerowego w danej grupie.
[] >DEL< ~ Klient w celu skasowania danego pliku z grupy wysyła
    na adres rozgłoszeniowy MCAST_ADDR ((!) [CORNER_CASE] dozwolone jest wysłanie także na adres unicast wybranego serwera) i port CMD_PORT
    pakiet SIMPL_CMD z poleceniem cmd = “DEL” oraz z nazwą pliku do skasowania w polu data.

[] Każdy węzeł serwerowy po otrzymaniu powyższego komunikatu usuwa trwale plik wskazany nazwą, jeśli taki przechowuje.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> Dodawanie pliku do grupy:
Klient w celu wysłania pliku do przechowywania go w grupie musi najpierw
> wyznaczyć węzeł, który będzie przechowywał ten plik.
W tym celu może wykorzystać polecenie służące rozpoznawaniu serwerów w grupie opisane wcześniej (patrz opis dla cmd = “HELLO”).

[] >ADD< ~ Po wybraniu serwera klient komunikuje się z nim,
    wysyłając na jego adres jednostkowy oraz port CMD_PORT pakiet CMPLX_CMD zawierający:
· pole cmd = “ADD”;
· pole param z rozmiarem pliku;
· pole data z nazwą pliku, który zostanie wysłany.

[] Węzeł serwerowy po otrzymaniu powyższego komunikatu musi odpowiedzieć klientowi
> w zależności od aktualnej możliwości przyjęcia pliku:
<NO_WAY> ::
>> jeśli serwer nie ma już miejsca na przechowanie pliku o rozmiarze wskazanym przez klienta,
    to odpowiada klientowi, wysyłając na jego adres jednostkowy i port nadawcy
    pakiet SIMPL_CMD:
· cmd = “NO_WAY”
· nazwą pliku, jaki klient chciał dodać, w polu data.
>> jeśli serwer przechowuje już obecnie plik o wskazanej przez węzeł kliencki nazwie,
    to serwer także powinien odpowiedzieć klientowi, wysyłając na jego adres
jednostkowy i port nadawcy pakiet SIMPL_CMD z cmd = “NO_WAY” oraz nazwą pliku,
jaki klient chciał dodać w polu data.
>> serwer powinien odmówić przyjęcia pliku także w przypadku gdy
– otrzymana nazwa pliku jest pusta
– lub zawiera znak '/’,
wysyłając na adres jednostkowy i port nadawcy pakiet SIMPL_CMD
· cmd = “NO_WAY”
· nazwą pliku, jaki klient chciał dodać, w polu data.
<CAN_ADD> ::
>> jeśli natomiast serwer dysponuje obecnie wolnym miejscem pozwalającym przechować
    plik o rozmiarze wskazanym przez nadawcę, to odpowiada klientowi na
jego adres jednostkowy i port nadawcy pakietem CMPLX_CMD zawierającym:
· pole cmd z wartością “CAN_ADD”;
· pole param z numerem portu TCP, na którym serwer oczekuje połączenia od klienta;
· pole data pozostaje puste.

[] >ADD< [wymianka] ~ Klient po otrzymaniu powyższego komunikatu powinien nawiązać połączenie TCP z węzłem serwerowym,
    używając jego adresu jednostkowego oraz otrzymanego portu TCP.
> Klient wysyła zawartość pliku, po czym powinien zakończyć połączenie.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

KLIENT:
[] umożliwia dodanie nowego pliku do plików przechowywanych przez grupę lub usunięcie dowolnego istniejącego pliku.

[] umożliwia pobranie zawartości dowolnego pliku z obecnie przechowywanych plików w grupie węzłów serwerowych

[] umożliwia pobranie listy plików obecnie przechowywanych w grupie węzłów serwerowych.


KOMUNIKATY:

SIMPL_CMD {
char[10] cmd    (2)
uint64 cmd_seq  (1)
char[] data
}

CMPLX_CMD {
char[10] cmd    (2)
uint64 cmd_seq  (1)
uint64 param    (1)
char[] data
}

(1) w BE(sieciowa kolejność); dla zmiennej o < 64 bity zrzutować (uint64) i użyć htobe64();
(2) krótsza wartość niż 10 znaków => uzupełnić zerami~ (zrobić wcześniej memset? przechowywać uzupełnione z zerami?)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MISC_INFO:
> Wszystkie rozmiary plików i przestrzeni dyskowej wyrażane są w liczbie bajtów.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Część A - Węzeł serwerowy:
[] Program powinien przyjmować następujące parametry linii poleceń:
> [-g] ~ MCAST_ADDR – adres rozgłaszania ukierunkowanego, ustawiany obowiązkowym parametrem -g węzła serwerowego;

> [-p] ~ CMD_PORT – port UDP używany do przesyłania i odbierania poleceń, ustawiany obowiązkowym parametrem -p węzła serwerowego;

> [-b] ~ MAX_SPACE – maksymalna liczba bajtów udostępnianej przestrzeni dyskowej na pliki grupy
    przez ten węzeł serwerowy, ustawiana opcjonalnym parametrem -b węzła serwerowego, wartość domyślna 52428800;

> [-f] ~ SHRD_FLDR – ścieżka do dedykowanego folderu dyskowego, gdzie mają być przechowywane pliki,
ustawiany parametrem obowiązkowym -f węzła serwerowego;

> [-t] ~ TIMEOUT – liczba sekund, jakie serwer może maksymalnie oczekiwać na połączenia od klientów,
    ustawiane opcjonalnym parametrem -t węzła serwerowego, wartość domyślna 5, wartość maksymalna 300.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] Serwer podczas uruchomienia powinien zindeksować wszystkie pliki znajdujące się bezpośrednio w folderze SHRD_FLDR,
a ich łączny rozmiar liczony w bajtach odjąć od parametru MAX_SPACE.
Serwer nie indeksuje plików w podkatalogach folderu SHRD_FLDR.

[] Serwer powinien podłączyć się do grupy rozgłaszania ukierunkowanego pod wskazanym adresem MCAST_ADDR.
Serwer powinien nasłuchiwać na porcie CMD_PORT poleceń otrzymanych z sieci protokołem UDP
także na swoim adresie unicast. Serwer powinien reagować na pakiety UDP zgodnie z protokołem opisanym wcześniej.

[] Jeśli serwer otrzyma polecenie dodania pliku lub pobrania pliku, to powinien otworzyć nowe gniazdo TCP
na losowym wolnym porcie przydzielonym przez system operacyjny i port ten przekazać w odpowiedzi
węzłowi klienckiemu. Serwer oczekuje maksymalnie TIMEOUT sekund na nawiązanie połączenia przez klienta
i jeśli takie nie nastąpi, to port TCP powinien zostać niezwłocznie zamknięty. (!) Serwer w czasie oczekiwania
na podłączenie się klienta i podczas przesyłania pliku powinien obsługiwać także inne zapytania od klientów.

[] Jeśli serwer otrzyma polecenia dodania pliku, to odpowiedź klientowi pakietem “CAN_ADD”
oznacza jednocześnie zarezerwowanie miejsca na serwerze niezbędnego do przyjęcia pliku od klienta.

[] Jakiekolwiek pakiety otrzymane przez program niezgodne ze specyfikacją protokołu powinny być pomijane przez serwer.
Informacja o niewłaściwym pakiecie powinna zostać wypisana na standardowe wyjście błędów,
jednolinijkowy komunikat o błędzie dla każdego niepoprawnego pakietu.
Informacja o błędzie powinna zawierać informację w formacie: [SPECYFIKACJA]

[PCKG ERROR] Skipping invalid package from {IP_NADAWCY}:{PORT_NADAWCY}.

gdzie {IP_NADAWCY} jest adresem IP nadawcy otrzymanego datagramu UDP
    a {PORT_NADAWCY} jest numerem portu nadawcy datagramu UDP

Autor programu powinien uzupełnić wiadomość po kropce o dodatkowe informacje opisujące błąd, ale bez użycia znaku nowej linii.

[] Serwer powinien zakończyć swoje działanie łagodnie, to znaczy kończąc otwarte połączenia oraz zwalniając pobrane zasoby systemowe, po otrzymaniu sygnału CTRL+C.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Część B - Węzeł kliencki:
[] Program powinien przyjmować następujące parametry linii poleceń:

[]  > [-g] ~ MCAST_ADDR – adres rozgłaszania ukierunkowanego (może być także adresem broadcast),
ustawiany {{obowiązkowym}} parametrem -g;
klient powinien używać tego adresu do wysyłania komunikatów do grupy węzłów serwerowych;

[]  > [-p] ~ CMD_PORT – port UDP, na którym nasłuchują węzły serwerowe, ustawiany {{obowiązkowym}} parametrem -p;
klient powinien używać tego numeru portu, aby wysyłać komunikaty do węzłów serwerowych;
// [0 - 65XXX]

> [-o] ~ OUT_FLDR – ścieżka do folderu dyskowego, gdzie klient będzie zapisywał pobrane pliki,
ustawiany parametrem {{obowiązkowym}} -o;
// walidacja

> [-t] ~ TIMEOUT – czas oczekiwania na zbieranie informacji od węzłów wyrażony w sekundach;
akceptowana wartość powinna być dodatnia i większa od zera; {{wartość domyślna 5}}; wartość maksymalna 300;
może zostać zmieniona przez opcjonalny parametr -t.
// [0 - 300]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] Klient po rozpoczęciu swojej pracy powinien oczekiwać na polecenia użytkownika na standardowym wejściu.
Każde polecenie kończy się znakiem nowej linii '\n'.
[]    Rozpoznawane przez program kliencki polecenia użytkownika (wielkość liter nie ma znaczenia):

[]  · discover – po otrzymaniu tego polecenia klient powinien wypisać na standardowe wyjście listę wszystkich węzłów serwerowych dostępnych aktualnie w grupie.
Klient oczekuje na zgłoszenia serwerów przez TIMEOUT sekund, w trakcie oczekiwania interfejs użytkownika zostaje wstrzymany.
Dla każdego odnalezionego serwera klient powinien wypisać na standardowe wyjście w jednej linii adres jednostkowy IP tego serwera,
    następnie w nawiasie adres MCAST_ADDR otrzymany od danego serwera, a na końcu rozmiar dostępnej przestrzeni dyskowej na tym serwerze.
Oczekiwany format takiej linii:

Found 10.1.1.28 (239.10.11.12) with free space 23456

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · search %s – klient powinien uznać polecenie za prawidłowe, także jeśli podany ciąg znaków %s jest pusty.
Po otrzymaniu tego polecenia klient wysyła po sieci do węzłów serwerowych zapytanie w celu wyszukania plików
    zawierających ciąg znaków podany przez użytkownika (lub wszystkich plików jeśli ciąg znaków %s jest pusty),
a następnie przez TIMEOUT sekund nasłuchuje odpowiedzi od węzłów serwerowych. Otrzymane listy plików powinny
zostać wypisane na standardowe wyjście po jednej linii na  jeden plik. Każda linia powinna zawierać informację:

{nazwa_pliku} ({ip_serwera})

gdzie:
– {nazwa_pliku} to nazwa pliku otrzymana z serwera;
– {ip_serwera} to adres jednostkowy IP serwera, z którego dana nazwa pliku została przesłana.

[]  Pakiety z odpowiedziami od serwerów z listą plików otrzymane po upływie TIMEOUT powinny zostać zignorowane przez klienta.
[]  Interfejs użytkownika zostaje wstrzymany na czas oczekiwania odpowiedzi z serwerów.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] · fetch %s – użytkownik może wskazać nazwę pliku %s, tylko jeśli nazwa pliku występowała na liście otrzymanej
w wyniku ostatniego wykonania polecenia search. (!) W przeciwnym przypadku klient nie podejmuje akcji pobierania pliku,
jednocześnie informując użytkownika o błędzie jednoliniowym komunikatem na standardowe wyjście.

[] Jeśli wskazany plik istnieje w [ostatnio wyszukiwanych (???)], to klient powinien wybrać dowolny węzeł serwerowy,
który przechowuje plik dokładnie wskazany przez podaną nazwę pliku %s i rozpocząć pobieranie pliku, zapisując plik do folderu OUT_FLDR.
[] W trakcie pobierania pliku użytkownik powinien móc kontynuować korzystanie z programu. Po zakończeniu pobierania pliku klient powinien
wypisać na standardowe wyjście komunikat o zakończeniu pobierania pliku w formacie:

File {%s} downloaded ({ip_serwera}:{port_serwera})

gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres IP unicast serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku.

Jeśli pobieranie pliku nie powiedzie się, to klient powinien wypisać na standardowe wyjście komunikat o błędzie w formacie:
File {%s} downloading failed ({ip_serwera}:{port_serwera}) {opis_błędu}

gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy IP serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku;
– {opis_błędu} to komunikat słowny opisujący przyczynę błędu.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[] · upload %s – użytkownik powinien wskazać ścieżkę do pliku, który chce wysłać do przechowania w grupie.
Użytkownik [[może]] podać pełną ścieżkę bezwzględną do pliku bądź ścieżkę względną.
Jeśli użytkownik wskaże nazwę pliku poprzez ścieżkę względną, to należy rozpocząć szukanie pliku do wysłania w katalogu bieżącym.
Jeśli wskazany plik nie istnieje, to klient powinien poinformować o tym fakcie użytkownika jednoliniową
    informacją o błędzie na standardowe wyjście w formacie

    File {%s} does not exist
    gdzie:
– {%s} to nazwa pliku.

[] Klient powinien podjąć próbę wysłania pliku [w pierwszej kolejności do węzła serwerowego o największej dostępnej wolnej przestrzeni].
Jeśli żaden węzeł nie dysponuje wystarczającym wolnym miejscem, to klient powinien poinformować użytkownika o braku możliwości załadowania pliku,
wypisując jednoliniową informację o błędzie na standardowe wyjście w formacie:

File {%s} too big
gdzie:
– {%s} to nazwa pliku.

[] W trakcie wysyłania pliku użytkownik powinien móc w dalszym ciągu korzystać z aplikacji.
Po zakończeniu wysyłania pliku klient powinien wypisać na standardowe wyjście komunikat o zakończeniu wysyłania pliku w formacie:

File {%s} uploaded ({ip_serwera}:{port_serwera})
gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy serwera;
– {port_serwera} to port TCP serwera użyty do pobrania pliku.

[] Jeśli wysyłanie pliku nie powiedzie się, to klient powinien wypisać na standardowe wyjście komunikat o błędzie w fomacie:

File {%s} uploading failed ({ip_serwera}:{port_serwera}) {opis_błędu}
gdzie:
– {%s} to nazwa pliku;
– {ip_serwera} to adres jednostkowy serwera
– {port_serwera} to port TCP serwera użyty do pobrania pliku;
– {opis_błędu} to komunikat słowny opisujący przyczynę błędu.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · remove %s – klient po otrzymaniu tego polecenia powinien wysłać do grupy serwerów
zlecenie usunięcia wskazanego przez użytkownika pliku. Polecenie jest prawidłowe,
tylko jeśli podana nazwa pliku %s jest niepusta.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[]  · exit – klient po otrzymaniu tego polecenia powinien zakończyć wszystkie otwarte połączenia
i [zwolnić pobrane zasoby z systemu(???)] oraz zakończyć pracę aplikacji.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MISC KLIENT:

[] Jakiekolwiek inne polecenia wpisane przez użytkownika powinny zostać uznane jako nieprawidłowe i zignorowane.
